# XSS Vulnerability in Search Results

## Severity
High

## Affected Files
- `src/components/SearchPanel.vue:131`
- `src/composables/useSearch.ts:52-55`

## Description
Search results display user-supplied content using `v-html`, which renders raw HTML. While the search term is escaped, the context/excerpt is not properly sanitized, creating a potential XSS vulnerability.

```javascript
// SearchPanel.vue:131
<p 
  class="text-sm text-gray-600 dark:text-gray-400 line-clamp-2"
  v-html="result.excerpt"
/>

// useSearch.ts:52-55
excerpt = excerpt.replace(
  new RegExp(`(${escapeRegex(searchQuery)})`, 'gi'),
  '<mark>$1</mark>'
);
```

## Why This Is A Problem

1. **Untrusted content**: Book content comes from untrusted EPUB files. Malicious EPUB files could contain script tags or event handlers in their HTML content.

2. **HTML injection**: If a book contains `<script>alert('XSS')</script>` or `<img src=x onerror=alert('XSS')>`, this will be executed when displayed in search results.

3. **User-controlled search**: Search query is user-controlled and, while escaped for the regex, could potentially bypass the escaping in edge cases.

4. **HTML parsing**: The code uses `DOMParser` and `textContent` to extract text, which is good. However, the replacement adds `<mark>` tags, and if the original HTML contains any problematic content, it could be preserved.

5. **CSP bypass**: Even with Content Security Policy headers, inline event handlers or certain HTML constructs could still execute depending on CSP configuration.

The current code:
- Uses `textContent` which strips HTML (good)
- But creates new HTML with `<mark>` tags
- Renders directly with `v-html` without sanitization (bad)

## Implementation Plan

1. **Immediate fix**: Sanitize the excerpt before rendering:

```javascript
// composables/useSearch.ts
import DOMPurify from 'dompurify';

export function useSearch() {
  const results = ref<SearchResult[]>([]);
  const isSearching = ref(false);
  const query = ref('');

  async function searchInBook(
    searchQuery: string,
    chapters: Chapter[]
  ): Promise<SearchResult[]> {
    if (!searchQuery.trim()) {
      results.value = [];
      return [];
    }

    isSearching.value = true;
    query.value = searchQuery;
    const searchResults: SearchResult[] = [];
    const maxResultsPerChapter = 10;

    try {
      for (let i = 0; i < chapters.length; i++) {
        const chapter = chapters[i];
        let resultsInChapter = 0;

        if (!chapter.content) continue;

        const parser = new DOMParser();
        const doc = parser.parseFromString(chapter.content, 'text/html');
        const body = doc.body;

        if (!body) continue;

        const text = body.textContent || '';
        const lowerText = text.toLowerCase();
        const lowerQuery = searchQuery.toLowerCase();

        let index = lowerText.indexOf(lowerQuery);

        while (index !== -1 && resultsInChapter < maxResultsPerChapter) {
          const contextLength = 50;
          const start = Math.max(0, index - contextLength);
          const end = Math.min(text.length, index + searchQuery.length + contextLength);
          let excerpt = text.substring(start, end);
          const matchedText = text.substring(index, index + searchQuery.length);

          if (start > 0) excerpt = '...' + excerpt;
          if (end < text.length) excerpt = excerpt + '...';

          // Safe HTML generation - only escape and wrap
          excerpt = escapeHtml(excerpt).replace(
            new RegExp(`(${escapeRegex(searchQuery)})`, 'gi'),
            '<mark>$1</mark>'
          );
          
          // Sanitize the final HTML
          const sanitizedExcerpt = DOMPurify.sanitize(excerpt, {
            ALLOWED_TAGS: ['mark'],
            ALLOWED_ATTR: [],
          });

          searchResults.push({
            chapterIndex: i,
            chapterTitle: chapter.title,
            excerpt: sanitizedExcerpt,
            cfi: chapter.href,
            searchText: searchQuery,
            matchedText,
            matchIndex: resultsInChapter,
          });

          resultsInChapter++;
          index = lowerText.indexOf(lowerQuery, index + 1);
        }
      }
    } finally {
      isSearching.value = false;
    }

    results.value = searchResults;
    return searchResults;
  }

  function escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function clearSearch(): void {
    results.value = [];
    query.value = '';
  }

  return {
    results,
    isSearching,
    query,
    searchInBook,
    clearSearch,
  };
}
```

2. Install DOMPurify dependency:

```bash
npm install dompurify
npm install -D @types/dompurify
```

3. **Alternative without external library**: Create a minimal safe HTML escaper:

```javascript
function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

function createSafeExcerpt(
  text: string,
  searchQuery: string,
  start: number,
  end: number
): string {
  const contextLength = 50;
  const excerptStart = Math.max(0, start - contextLength);
  const excerptEnd = Math.min(text.length, end + contextLength);
  
  let excerpt = text.substring(excerptStart, excerptEnd);
  
  if (excerptStart > 0) excerpt = '...' + excerpt;
  if (excerptEnd < text.length) excerpt = excerpt + '...';
  
  // Escape the entire excerpt first
  let safeExcerpt = escapeHtml(excerpt);
  
  // Find and wrap the matched text in <mark> tags
  // We need to calculate the offset in the escaped string
  const escapedSearchQuery = escapeHtml(searchQuery);
  safeExcerpt = safeExcerpt.replace(
    new RegExp(`(${escapeRegex(escapedSearchQuery)})`, 'gi'),
    '<mark>$1</mark>'
  );
  
  return safeExcerpt;
}
```

4. **Best practice**: Use a dedicated Vue directive for safe HTML:

```javascript
// directives/safeHtml.ts
import DOMPurify from 'dompurify';

const safeHtml = {
  mounted(el: HTMLElement, binding: { value: string }) {
    el.innerHTML = DOMPurify.sanitize(binding.value, {
      ALLOWED_TAGS: ['mark', 'b', 'i', 'em', 'strong'],
      ALLOWED_ATTR: [],
    });
  },
  updated(el: HTMLElement, binding: { value: string }) {
    el.innerHTML = DOMPurify.sanitize(binding.value, {
      ALLOWED_TAGS: ['mark', 'b', 'i', 'em', 'strong'],
      ALLOWED_ATTR: [],
    });
  },
};

export default safeHtml;
```

Then use it in component:

```javascript
import safeHtmlDirective from '@/directives/safeHtml';

export default {
  directives: {
    safeHtml: safeHtmlDirective,
  },
};
```

And in template:

```html
<p 
  class="text-sm text-gray-600 dark:text-gray-400 line-clamp-2"
  v-safe-html="result.excerpt"
/>
```

5. **Security best practices** for EPUB readers:

```javascript
// composables/useSafeHtml.ts
import DOMPurify from 'dompurify';

// Configure DOMPurify for EPUB content
DOMPurify.addHook('uponSanitizeAttribute', (node, data) => {
  // Allow only safe attributes
  const allowedAttributes = ['href', 'src', 'alt', 'title'];
  if (!allowedAttributes.includes(data.attrName)) {
    node.removeAttribute(data.attrName);
  }
});

DOMPurify.addHook('uponSanitizeElement', (node, data) => {
  // Remove dangerous elements
  if (data.tagName === 'SCRIPT' || data.tagName === 'STYLE') {
    node.remove();
  }
});

export function sanitizeBookContent(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: [
      'p', 'br', 'span', 'div',
      'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
      'strong', 'b', 'em', 'i',
      'a', 'img',
      'ul', 'ol', 'li',
      'blockquote', 'code', 'pre',
      'mark', 'sub', 'sup',
    ],
    ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'id'],
    ALLOW_DATA_ATTR: false,
  });
}

export function sanitizeSearchExcerpt(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['mark'],
    ALLOWED_ATTR: [],
  });
}
```

6. Add security tests:

```javascript
// tests/security.test.ts
import { sanitizeSearchExcerpt } from '@/composables/useSafeHtml';

describe('HTML Sanitization', () => {
  it('should remove script tags', () => {
    const malicious = '<script>alert("XSS")</script>hello';
    const safe = sanitizeSearchExcerpt(malicious);
    expect(safe).not.toContain('<script>');
    expect(safe).toContain('hello');
  });

  it('should remove event handlers', () => {
    const malicious = '<img src=x onerror="alert(1)">';
    const safe = sanitizeSearchExcerpt(malicious);
    expect(safe).not.toContain('onerror');
  });

  it('should allow mark tags for highlighting', () => {
    const html = '<mark>highlighted</mark>';
    const safe = sanitizeSearchExcerpt(html);
    expect(safe).toContain('<mark>');
  });
});
```
