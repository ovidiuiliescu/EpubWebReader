# Path Traversal Vulnerability in File Path Handling

## Severity
Medium

## Affected Files
- `src/composables/useEpub.ts:357-390` (resolveImagePath function)
- `src/composables/useEpub.ts:478-490` (chapter path resolution)
- `src/composables/useEpub.ts:378-388` (zip file lookup)
- `src/components/BookViewer.vue:90-108` (handleLinkClick function)

## Description
The application does not properly validate or sanitize file paths from EPUB archives, making it vulnerable to path traversal attacks. Malicious EPUB files could use path traversal sequences (e.g., `../../`) to access files outside the intended directory or inject unexpected files.

```typescript
// Lines 357-390 in useEpub.ts - resolveImagePath function
async function resolveImagePath(href: string, baseUrl: string | undefined, chapterPath: string): Promise<string> {
  if (href.startsWith('http://') || href.startsWith('https://')) {
    try {
      const parsed = new URL(href);
      return parsed.pathname; // NO VALIDATION
    } catch {
      return href;
    }
  }

  if (href.startsWith('data:')) {
    return href;
  }

  if (href.startsWith('#')) {
    return href;
  }

  try {
    if (baseUrl) {
      const fullUrl = new URL(href, `http://localhost/${baseUrl}`); // UNSAFE
      return fullUrl.pathname.substring(1);
    }
  } catch {
    return href;
  }

  const chapterDirEnd = chapterPath.lastIndexOf('/');
  if (chapterDirEnd >= 0) {
    const chapterDir = chapterPath.substring(0, chapterDirEnd + 1);
    try {
      const fullUrl = new URL(href, `http://localhost/${chapterDir}`); // UNSAFE
      return fullUrl.pathname.substring(1);
    } catch {
      return chapterDir + href; // UNSAFE - PATH TRAVERSAL
    }
  }

  return href;
}
```

```typescript
// Lines 378-388 in useEpub.ts - chapter path resolution
let zipFile = archiveZip.file(chapterPath); // NO VALIDATION

if (!zipFile) {
  const allFiles = archiveZip.files ? Object.keys(archiveZip.files) : [];
  const matchingFile = allFiles.find(f => f.endsWith(chapterPath) || f.endsWith(`/${chapterPath}`));
  
  if (matchingFile) {
    zipFile = archiveZip.file(matchingFile);
  }
}
```

```typescript
// Lines 90-108 in BookViewer.vue - handleLinkClick function
chapterPath = decodeURIComponent(chapterPath).replace(/^\/+/, ''); // NO VALIDATION

let chapterIndex = bookStore.chapters.findIndex(chapter => {
  const chapterHref = decodeURIComponent(chapter.href).replace(/^\/+/, '');
  // ... matching logic without proper validation
});
```

## Potential Attack Vectors

### 1. Path Traversal via Image Sources
EPUB file structure with malicious image paths:
```
EPUB/
├── OEBPS/
│   ├── chapter1.xhtml
│   └── images/
│       └── cover.jpg
├── ../../etc/passwd        ← Malicious path
└── ../../../windows/system32/config
```

Malicious image in EPUB:
```html
<img src="../../../etc/passwd" alt="system file">
<img src="..\..\..\Windows\System32\drivers\etc\hosts">
```

When application resolves this path, it could potentially:
- Try to read files outside the EPUB archive
- Leak information about the system
- Cause application errors/crashes

### 2. Path Traversal via Chapter Links
```html
<!-- Malicious EPUB chapter with malicious link -->
<a href="../../../sensitive-data.xml">Read More</a>
<a href="../../../../Users/user/.ssh/id_rsa">SSH Key</a>
<a href="..\..\..\..\..\..\..\Windows\System32\config">System Config</a>
```

### 3. URL-encoded Path Traversal
```html
<!-- Encoded traversal sequences -->
<img src="..%2F..%2F..%2Fetc%2Fpasswd">
<img src="..%5c..%5c..%5cWindows%5cSystem32">
<a href="%2e%2e%2f%2e%2e%2fsensitive">Link</a>
```

### 4. Null Byte Injection
```html
<img src="../../../etc/passwd%00.jpg">
```

### 5. Symlink Attacks (if filesystem access were enabled)
```
EPUB/
├── safe-chapter.xhtml
└── malicious-symlink -> /etc/passwd
```

### Example Attack Scenario
```html
<!-- Malicious EPUB content -->
<!DOCTYPE html>
<html>
<body>
  <h1>Chapter 1</h1>
  
  <!-- Attempt to read sensitive files -->
  <img src="../../../etc/passwd" onerror="alert('Failed to access /etc/passwd')">
  <img src="../../../../Windows/System32/drivers/etc/hosts" onerror="alert('Failed to access hosts file')">
  
  <!-- Try to access user data -->
  <img src="../../../Users/user/Documents/secrets.txt">
  
  <!-- Attempt to read application configuration -->
  <img src="../package.json">
  <img src="../../.env"> <!-- If .env file exists -->
</body>
</html>
```

## Implementation Plan

### Step 1: Create path validation utility
Create `src/utils/pathValidator.ts`:
```typescript
/**
 * Path Validation Utility
 * 
 * Prevents path traversal and validates file paths
 */

/**
 * Check for path traversal sequences
 */
const TRAVERSAL_PATTERNS = [
  /\.\.\//,           // ../
  /\.\.\\/,           // ..\
  /%2e%2e%2f/i,      // URL encoded ../
  /%2e%2e%5c/i,      // URL encoded ..\
  /%252e%252e%252f/i, // Double encoded ../
  /\.\.\/\.\.\//,     // nested traversal
  /\.\.\\\.\.\\/,     // nested windows traversal
];

/**
 * Check for null byte injection
 */
const NULL_BYTE_PATTERN = /\0/;

/**
 * Check for dangerous path components
 */
const DANGEROUS_COMPONENTS = [
  '/etc/passwd',
  '/etc/shadow',
  '/etc/hosts',
  '/windows/system32',
  'windows/system32',
  'users/.ssh',
  'program files',
  '\\\\',  // UNC paths
  '//',     // Absolute paths (if not http)
];

/**
 * Allowed file extensions for EPUB content
 */
const ALLOWED_EXTENSIONS = [
  '.xhtml', '.html', '.htm', '.xml',
  '.css',
  '.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp',
  '.ttf', '.otf', '.woff', '.woff2',
  '.ncx', '.opf', '.xml'
];

/**
 * Maximum path depth (number of directory levels)
 */
const MAX_PATH_DEPTH = 10;

/**
 * Maximum path length
 */
const MAX_PATH_LENGTH = 255;

/**
 * Sanitize and validate a file path
 */
export function sanitizePath(path: string, allowedExtensions?: string[]): string {
  if (!path || typeof path !== 'string') {
    return '';
  }

  let sanitized = path.trim();

  // Check for null bytes
  if (NULL_BYTE_PATTERN.test(sanitized)) {
    throw new SecurityError('Path contains null byte', path);
  }

  // Decode URL encoding
  sanitized = decodeURIComponent(sanitized);

  // Normalize path separators
  sanitized = sanitized.replace(/\\/g, '/');

  // Remove leading/trailing separators (but keep single for root)
  sanitized = sanitized.replace(/^\/+/, '').replace(/\/+$/, '');

  // Check for path traversal
  for (const pattern of TRAVERSAL_PATTERNS) {
    if (pattern.test(sanitized)) {
      throw new SecurityError('Path contains traversal sequence', path);
    }
  }

  // Check for dangerous components
  const lowerPath = sanitized.toLowerCase();
  for (const dangerous of DANGEROUS_COMPONENTS) {
    if (lowerPath.includes(dangerous)) {
      throw new SecurityError('Path contains dangerous component', path);
    }
  }

  // Validate path depth
  const depth = sanitized.split('/').filter(p => p).length;
  if (depth > MAX_PATH_DEPTH) {
    throw new SecurityError(`Path depth exceeds limit (${depth} > ${MAX_PATH_DEPTH})`, path);
  }

  // Validate path length
  if (sanitized.length > MAX_PATH_LENGTH) {
    throw new SecurityError(`Path length exceeds limit (${sanitized.length} > ${MAX_PATH_LENGTH})`, path);
  }

  // Validate file extension if provided
  if (allowedExtensions && allowedExtensions.length > 0) {
    const ext = sanitized.split('.').pop()?.toLowerCase();
    if (ext && !allowedExtensions.includes(`.${ext}`)) {
      throw new SecurityError(`Invalid file extension: .${ext}`, path);
    }
  }

  return sanitized;
}

/**
 * Check if path is relative (doesn't start with /)
 */
export function isRelativePath(path: string): boolean {
  if (!path) return false;
  return !path.startsWith('/') && !path.startsWith('\\');
}

/**
 * Join path segments safely
 */
export function safePathJoin(...segments: string[]): string {
  const joined = segments
    .map(s => s.replace(/\\/g, '/').replace(/^\/+|\/+$/g, ''))
    .filter(s => s.length > 0)
    .join('/');

  return sanitizePath(joined);
}

/**
 * Get file extension from path
 */
export function getFileExtension(path: string): string | null {
  if (!path) return null;
  const match = path.match(/\.([a-zA-Z0-9]+)$/);
  return match ? `.${match[1].toLowerCase()}` : null;
}

/**
 * Validate filename (not full path)
 */
export function sanitizeFilename(filename: string): string {
  if (!filename) return '';

  // Remove path components
  const name = filename.split('/').pop()?.split('\\').pop() || filename;
  
  // Remove dangerous characters (keep: letters, numbers, spaces, hyphens, underscores, dots)
  const sanitized = name.replace(/[<>:"|?*\x00-\x1F]/g, '');
  
  return sanitizePath(sanitized);
}

/**
 * SecurityError class for path validation errors
 */
export class SecurityError extends Error {
  constructor(
    message: string,
    public readonly originalPath: string,
    public readonly code: string = 'PATH_VALIDATION_ERROR'
  ) {
    super(message);
    this.name = 'SecurityError';
  }
}

/**
 * Validate that path stays within a base directory
 */
export function isPathWithinBase(fullPath: string, basePath: string): boolean {
  const normalizedFull = fullPath.replace(/\\/g, '/');
  const normalizedBase = basePath.replace(/\\/g, '/');
  
  const relative = normalizedFull.replace(normalizedBase, '');
  
  // If relative path starts with ../, it's outside base
  if (relative.startsWith('../') || relative.startsWith('..\\')) {
    return false;
  }
  
  return true;
}

/**
 * Strip dangerous protocols from paths
 */
export function stripDangerousProtocols(path: string): string {
  const dangerousProtocols = [
    'javascript:',
    'vbscript:',
    'data:',
    'file:',
    'mailto:',
    'tel:',
  ];

  let stripped = path;
  for (const protocol of dangerousProtocols) {
    const regex = new RegExp(protocol.replace(':', ':\\s*'), 'gi');
    stripped = stripped.replace(regex, '');
  }

  return stripped;
}
```

### Step 2: Update resolveImagePath in useEpub.ts
```typescript
import {
  sanitizePath,
  getFileExtension,
  ALLOWED_EXTENSIONS
} from '@/utils/pathValidator';

async function resolveImagePath(href: string, baseUrl: string | undefined, chapterPath: string): Promise<string> {
  if (href.startsWith('http://') || href.startsWith('https://')) {
    try {
      const parsed = new URL(href);
      // Validate that URL is safe
      const pathname = sanitizePath(parsed.pathname);
      return pathname;
    } catch {
      return href;
    }
  }

  if (href.startsWith('data:')) {
    // Validate data URL - only allow images
    if (!href.startsWith('data:image/')) {
      console.warn('Blocked non-image data URL:', href);
      return '';
    }
    return href;
  }

  if (href.startsWith('#')) {
    return href;
  }

  // Strip dangerous protocols
  href = stripDangerousProtocols(href);

  try {
    if (baseUrl) {
      const fullUrl = new URL(href, `http://localhost/${baseUrl}`);
      const pathname = sanitizePath(fullUrl.pathname);
      return pathname.substring(1);
    }
  } catch {
    // Fall through to chapter-relative path
  }

  const chapterDirEnd = chapterPath.lastIndexOf('/');
  if (chapterDirEnd >= 0) {
    const chapterDir = sanitizePath(chapterPath.substring(0, chapterDirEnd + 1));
    try {
      const fullUrl = new URL(href, `http://localhost/${chapterDir}`);
      const pathname = sanitizePath(fullUrl.pathname);
      return pathname.substring(1);
    } catch (error) {
      if (error instanceof SecurityError) {
        console.warn('Security error in image path:', error.message);
        return '';
      }
      return '';
    }
  }

  return sanitizePath(href);
}
```

### Step 3: Update loadChapterContent in useEpub.ts
```typescript
import { sanitizePath, getFileExtension } from '@/utils/pathValidator';

// ... in loadChapterContent function ...

let chapterPath: string;
if (href.startsWith('http://') || href.startsWith('https://')) {
  try {
    const parsed = new URL(href);
    chapterPath = sanitizePath(parsed.pathname);
  } catch (error) {
    if (error instanceof SecurityError) {
      console.warn('Security error in chapter path:', error.message);
      return `<p>Unable to load chapter: ${title}</p>`;
    }
    chapterPath = href;
  }
} else if (baseUrl) {
  try {
    const fullUrl = new URL(href, baseUrl);
    chapterPath = sanitizePath(fullUrl.pathname);
  } catch (error) {
    if (error instanceof SecurityError) {
      console.warn('Security error in chapter path:', error.message);
      return `<p>Unable to load chapter: ${title}</p>`;
    }
    chapterPath = href;
  }
} else {
  chapterPath = sanitizePath(href);
}

chapterPath = chapterPath.replace(/^\//, '');
chapterPath = decodeURIComponent(chapterPath);

let zipFile = archiveZip.file(chapterPath);

if (!zipFile) {
  const allFiles = archiveZip.files ? Object.keys(archiveZip.files) : [];
  // Safe: only match at end of paths, not using startsWith
  const matchingFile = allFiles.find(f => {
    const normalized = sanitizePath(f);
    return normalized.endsWith(chapterPath) || 
           normalized.endsWith(`/${chapterPath}`);
  });
  
  if (matchingFile) {
    zipFile = archiveZip.file(matchingFile);
  }
}

if (!zipFile) {
  console.warn(`Chapter file not found in archive: ${title} (${chapterPath})`);
  return `<p>Unable to load chapter: ${title}</p>`;
}
```

### Step 4: Update processImages in useEpub.ts
```typescript
import { sanitizePath } from '@/utils/pathValidator';

// ... in processImages function ...

for (const img of images) {
  const src = img.getAttribute('src');
  if (!src) continue;

  if (imageUrls.has(src)) {
    img.setAttribute('src', imageUrls.get(src)!);
    continue;
  }

  if (src.startsWith('data:')) {
    if (!src.startsWith('data:image/')) {
      console.warn('Blocked non-image data URL');
      continue;
    }
    continue;
  }

  const resolvedPath = await resolveImagePath(src, baseUrl, chapterPath);
  
  // Check if path was sanitized to empty (blocked)
  if (!resolvedPath) {
    console.warn(`Blocked image with invalid path: ${src}`);
    img.removeAttribute('src');
    continue;
  }
  
  let normalizedPath = sanitizedPath.replace(/^\//, '');
  
  // Additional validation
  try {
    normalizedPath = sanitizePath(normalizedPath, ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp']);
  } catch (error) {
    if (error instanceof SecurityError) {
      console.warn('Invalid image file type:', error.message);
      img.removeAttribute('src');
      continue;
    }
  }

  // ... rest of function ...
}
```

### Step 5: Update handleLinkClick in BookViewer.vue
```typescript
import { sanitizePath, SecurityError } from '@/utils/pathValidator';

async function handleLinkClick(event: MouseEvent) {
  const target = event.target as HTMLElement;
  const link = target.closest('a') as HTMLAnchorElement | null;

  if (!link) return;

  const href = link.getAttribute('href');
  if (!href) return;

  if (href.startsWith('#')) {
    event.preventDefault();
    const elementId = href.substring(1);
    // Validate fragment ID
    const safeId = sanitizePath(elementId, []);
    nextTick(() => {
      const targetElement = articleRef.value?.querySelector(`#${safeId}`);
      if (targetElement) {
        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    });
    return;
  }

  if (href.startsWith('http://') || href.startsWith('https://') || 
      href.startsWith('mailto:') || href.startsWith('tel:')) {
    return;
  }

  event.preventDefault();

  let chapterPath = href;
  let fragmentId = '';
  const fragmentIndex = href.indexOf('#');
  if (fragmentIndex >= 0) {
    chapterPath = href.substring(0, fragmentIndex);
    fragmentId = href.substring(fragmentIndex + 1);
  }

  try {
    // SANITIZE CHAPTER PATH
    chapterPath = sanitizePath(chapterPath, ['.xhtml', '.html', '.htm']);
  } catch (error) {
    if (error instanceof SecurityError) {
      console.warn('Blocked invalid chapter link:', error.message);
      return;
    }
  }

  chapterPath = decodeURIComponent(chapterPath).replace(/^\/+/, '');

  let chapterIndex = bookStore.chapters.findIndex(chapter => {
    const chapterHref = sanitizePath(decodeURIComponent(chapter.href), ['.xhtml', '.html', '.htm']);
    const safeChapterPath = chapterPath.replace(/^\/+/, '');
    
    if (chapterHref === safeChapterPath) return true;
    
    // Safe matching: only compare end of paths
    if (chapterHref.endsWith(`/${safeChapterPath}`) || 
        safeChapterPath.endsWith(`/${chapterHref}`)) return true;
    
    // Compare only filename
    const chapterName = chapterHref.split('/').pop() || chapterHref;
    const linkName = safeChapterPath.split('/').pop() || safeChapterPath;
    return chapterName === linkName || 
           chapterName.replace(/\.[^/.]+$/, '') === linkName.replace(/\.[^/.]+$/, '');
  });

  if (chapterIndex >= 0) {
    bookStore.setChapter(chapterIndex);

    if (fragmentId) {
      const safeFragmentId = sanitizePath(fragmentId, []);
      nextTick(() => {
        const targetElement = articleRef.value?.querySelector(`#${safeFragmentId}`);
        if (targetElement) {
          targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      });
    }
    return;
  }

  const newChapter = await epub.loadChapterByHref(chapterPath);
  if (newChapter) {
    bookStore.addChapter(newChapter);
    chapterIndex = bookStore.chapters.length - 1;
    bookStore.setChapter(chapterIndex);

    if (fragmentId) {
      const safeFragmentId = sanitizePath(fragmentId, []);
      nextTick(() => {
        const targetElement = articleRef.value?.querySelector(`#${safeFragmentId}`);
        if (targetElement) {
          targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      });
    }
  }
}
```

### Step 6: Add tests
Create `tests/path-validator.test.ts`:
```typescript
import { describe, it, expect } from 'vitest';
import {
  sanitizePath,
  safePathJoin,
  getFileExtension,
  sanitizeFilename,
  isPathWithinBase,
  SecurityError
} from '@/utils/pathValidator';

describe('sanitizePath', () => {
  it('should accept normal paths', () => {
    expect(sanitizePath('OEBPS/chapter1.xhtml')).toBe('OEBPS/chapter1.xhtml');
    expect(sanitizePath('images/cover.jpg')).toBe('images/cover.jpg');
  });

  it('should reject path traversal with ../', () => {
    expect(() => sanitizePath('../etc/passwd')).toThrow(SecurityError);
    expect(() => sanitizePath('OEBPS/../../../etc/passwd')).toThrow(SecurityError);
  });

  it('should reject URL-encoded traversal', () => {
    expect(() => sanitizePath('%2e%2e%2fetc/passwd')).toThrow(SecurityError);
  });

  it('should reject null bytes', () => {
    expect(() => sanitizePath('chapter\x00.xhtml')).toThrow(SecurityError);
  });

  it('should normalize path separators', () => {
    expect(sanitizePath('OEBPS\\chapter1.xhtml')).toBe('OEBPS/chapter1.xhtml');
  });

  it('should strip leading/trailing separators', () => {
    expect(sanitizePath('/chapter1.xhtml/')).toBe('chapter1.xhtml');
  });

  it('should enforce extension whitelist when provided', () => {
    expect(() => sanitizePath('test.exe', ['.xhtml', '.html'])).toThrow(SecurityError);
    expect(() => sanitizePath('test.txt', ['.xhtml', '.html'])).toThrow(SecurityError);
    expect(sanitizePath('test.xhtml', ['.xhtml', '.html'])).toBe('test.xhtml');
  });
});

describe('safePathJoin', () => {
  it('should join paths safely', () => {
    expect(safePathJoin('OEBPS', 'chapter1.xhtml')).toBe('OEBPS/chapter1.xhtml');
    expect(safePathJoin('OEBPS', 'images', 'cover.jpg')).toBe('OEBPS/images/cover.jpg');
  });

  it('should prevent traversal in joined paths', () => {
    expect(() => safePathJoin('OEBPS', '../etc/passwd')).toThrow(SecurityError);
  });
});

describe('getFileExtension', () => {
  it('should extract file extension', () => {
    expect(getFileExtension('chapter1.xhtml')).toBe('.xhtml');
    expect(getFileExtension('cover.jpg')).toBe('.jpg');
  });

  it('should handle paths without extension', () => {
    expect(getFileExtension('README')).toBeNull();
  });
});

describe('sanitizeFilename', () => {
  it('should remove path components', () => {
    expect(sanitizeFilename('/etc/passwd')).toBe('passwd');
    expect(sanitizeFilename('Windows\\System32\\config')).toBe('config');
  });

  it('should remove dangerous characters', () => {
    expect(sanitizeFilename('test<file>.exe')).toBe('testfile.exe');
    expect(sanitizeFilename('test:file.exe')).toBe('testfile.exe');
  });
});

describe('isPathWithinBase', () => {
  it('should return true for paths within base', () => {
    expect(isPathWithinBase('/OEBPS/chapter1.xhtml', '/OEBPS')).toBe(true);
  });

  it('should return false for paths outside base', () => {
    expect(isPathWithinBase('/etc/passwd', '/OEBPS')).toBe(false);
    expect(isPathWithinBase('/OEBPS/../etc/passwd', '/OEBPS')).toBe(false);
  });
});
```

## Additional Recommendations
1. **Input Validation**: Always validate user input and file paths
2. **Whitelist Approach**: Use whitelists for allowed file types and paths
3. **Logging**: Log all blocked path attempts for security monitoring
4. **Error Handling**: Provide user-friendly error messages for blocked paths
5. **Testing**: Create comprehensive test suite for path validation
6. **Code Review**: Regular security reviews of path handling code

## Related Issues
- See also: `missing-file-type-validation.md` (File type validation)
- See also: `unsafe-data-url-handling.md` (Data URL validation)
